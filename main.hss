# OHR Community Point & Click Adventure
# main.hss
# created by kylekrack

include, movement.hss
include, ui.hss

globalVariable, begin
    0,lmbDown
    1,rmbDown
    2,lmbUp
    3,rmbUp
    4,escPress
    5,gameIsRunning
    6,paused
    7,hud
    8,interactCol           # Per-map slice collection that has interactive slices like Look and Door
    9,actionState
    10,destinationMarker     # To be replaced with a lookup code
end

defineConstant, begin
    # Action States - player can choose whether their click means a look, walk, etc. 
    0,state:walk
    1,state:look
    2,state:use
    3,state:talk
    # Movement values
    2,move:speed
    0,move:friction
    # Player hitbox
    10,player:width
    10,player:height
end

plotscript, keypressHandler, begin
    # Gets and processes all button presses
    # Mouse Buttons
    if(mouseRelease(leftButton)) then(
        lmbUp := true
    )
    if(mouseRelease(rightButton)) then(
        rmbUp := true
    )
    if(mouseButton(leftButton)) then(
        lmbDown := true
    )
    if(mouseButton(rightButton)) then(
        rmbDown := true
    )
    
    # Keyboard
    if(keypress(key:esc)) then(
        escPress := true
    )
end

plotscript, newGame, begin
    # Run when the game is run, initializes things like the mouse and hud
    # Initializations
    suspendPlayer
    initMouse
    unhideMouseCursor
    gameIsRunning := true
    setSliceSize(getHeroSlice(me), player:width, player:height)
    hud := loadSliceCollection(0)
    mainGameLoop
end

script, mainGameLoop, begin
    # Runs every in-game tick, calls to functions from outside this file
    variable(x, y, sl, oldPlayerX, oldPlayerY)
    # Init old position to -1, to indicate no movement has ocurred
    oldPlayerX := -1
    oldPlayerY := -1
   
    while(gameIsRunning) do(
        x := mousePixelX, y := mousePixelY
        # Mouse Hover
        mouseHover(x, y)
        
        # Check Paused: everything after this will be skipped if game is paused
        if(paused) then(
            resetInputs()
            wait
            continue
        )
        
        # Pause Skip Line
        # ---------------------------
        
        # Mouse Controls
        if(lmbDown) then(
            # Events when lmb clicked down:
            # * Click to Move
            lmbDownActions(x, y)
        ) elseif(lmbUp) then(
            # Events when lmb lifted:
            # * Look at something
            # * Use item on something
            lmbUpActions(x, y)
        ) elseif(rmbDown) then(
            # Events when rmb clicked down:
            rmbDownActions(x, y)
        ) elseif(rmbUp) then(
            # Events when rmb lifted:
            rmbUpActions(x, y)
        )
        
        # Player Movement
        if(destinationMarker) then(
            # Either player is still moving, is blocked from moving, 
            # or has reached destination
            x := sliceX(getHeroSlice(me)) + (sliceWidth(getHeroSlice(me))/2) # Middle of hero slice
            y := sliceY(getHeroSlice(me)) + sliceHeight(getHeroSlice(me))   # Bottom of hero slice
            checkContinueMove(x, y)
        )
        
        # Doors
        # Check if player slice is colliding with a slice on interactCol with 
        # the sli:door lookup code
        sl := findCollidingSlice(interactCol, getHeroSlice(me), 0, true, false)
        if(sl) then(
            if(getSliceLookup(sl) == sli:door) then(
                x := getSliceExtra(sl, extra1) # Store destination x in tiles
                y := getSliceExtra(sl, extra2) # Store destination y in tiles
                useDoor(getSliceExtra(sl, extra0)) # Store door id here
                putHero(me, x*20, y*20)
            )
        )
        
        resetInputs()
       
        wait
    )
    
    subscript, resetInputs, begin
        lmbDown := false
        rmbDown := false
        lmbUp := false
        rmbUp := false
        escPress := false
    end
    
    subscript, checkContinueMove, playerX, playerY, begin
        # Checks if player is at the same place as last tick (stuck)
        # or if the player has reached their destination
        # Continue moving if able to and not at destination
        if(oldPlayerX == -1 && oldPlayerY == -1) then(
            # Set player's initial position: when they started moving
            oldPlayerX := playerX
            oldPlayerY := playerY
            # Move towards destination marker
            x := (sliceX(destinationMarker) + 5) -- playerX # The center of the ellipse -- player x
            y := (sliceY(destinationMarker) + 5) -- playerY # The center of the ellipse -- player y
            movePlayer(x, y)
        ) elseif((oldPlayerX == playerX && oldPlayerY == playerY)
        || (abs((sliceX(destinationMarker) + 5) -- playerX) < move:speed+1
            && abs((sliceY(destinationMarker) + 5) -- playerY) < move:speed+1
            )
        ) then(
            # Stuck
            oldPlayerX := -1, oldPlayerY := -1 # Reset old values
            # Remove destination marker
            freeSlice(destinationMarker)
            destinationMarker := 0
        ) else(
            # Move towards destination marker
            x := (sliceX(destinationMarker) + 5) -- playerX # The center of the ellipse -- player x
            y := (sliceY(destinationMarker) + 5) -- playerY # The center of the ellipse -- player y
            movePlayer(x, y)
        )
    end
end

plotscript, mapAutorun, col, begin
    # The default map autorun script. Special autorun scripts should call this one
    # col is the interactive slice collection to load for this map
    if(interactCol) then(freeSlice(interactCol))
    interactCol := loadSliceCollection(col)
end